       FUNCTION CALC_LAT_LONG_LAM, ALATITUDE_LL, ALONGITUDE_LL, $
                                   STND_PARALLEL, ORIENT, $
                                   CLONG_EW, AMESH_LENGTH, $
                                   ALATITUDE, ALONGITUDE, NX, NY
;
;       AWIPS WFO APPLICATION PREPARED BY TDL/GSC/PRC
;       MAY 1996   ESTILONG/GLAHN/SIMMS    PRC/TDL/GSC   HP
;
;       July 2012  Morris, GPM GV, SAIC - converted to IDL
; 
;       PURPOSE 
;            SUBROUTINE TO CONVERT IX,IY COORDINATES FOR A GRID
;            OVERLAIN ON A LAMBERT CONFORMAL MAP PROJECTION TO
;            LATITUDE AND LONGITUDE.  ADAPTED FROM STACKPOLE'S
;            ROUTINE, WHICH COMPUTED POINT-BY-POINT INSTEAD
;            OF A WHOLE ARRAY, AND WHOSE INPUT WAS IN TERMS OF
;            EAST LONGITUDE.  THE INPUT AND OUTPUT VARIABLE
;            NAMES HAVE BEEN CHANGED TO BE CONSISTENT WITH OTHER
;            ROUTINES IN THE PARAMETER DERIVATION SUITE.
;            ACCORDING TO STACKPOLE (SUBROUTINE W3FB12), THE
;            FORMULAE AND NOTATION ARE LOOSELY BASED ON HOKE, HAYES,
;            AND RENNINGER'S "MAP PROJECTIONS AND GRID SYSTEMS...",
;            MARCH 1981, AFGWC/TN-79/003.  THE LATITUDE MUST BE
;            POSITIVE IN THE NORTHERN HEMISPHERE AND NEGATIVE IN
;            THE SOUTHERN HEMISPHERE.  THE LONGITUDE CAN BE INPUT
;            IN EITHER EAST OR WEST LONGITUDE AND CAN BE IN THE
;            RANGE -360 TO +360; THE OUTPUT LONGITUDE GRID
;            WILL BE IN THE SAME CONVENTION AS THE INPUT AND
;            THE VALUES WILL BE IN THE RANGE 0-360--ALL POSITIVE.
;            NOTE THAT THE LONGITUDE OF THE LOWER LEFT CORNER
;            AND THE ORIENTATION MUST BOTH EITHER BE EAST OR WEST
;            LONGITUDE.  THIS ROUTINE CANNOT BE USED WITH A 
;            STANDARD PARALLEL AT EITHER POLE OR WITHIN 10 DEGREES
;            OF THE EQUATOR.  A NORTHERN HEMISPHERIC PROJECTION IS
;            INDICATED BY A POSITIVE STANDARD PARALLEL; OTHERWISE,
;            THE PROJECTION IS FOR THE SOUTHERN HEMISPHERE.  ALL
;            LATITUDES AND LONGITUDES INPUT AND OUTPUT ARE IN DEGREES.
;
;        DATA SETS USED
;            NONE.
;
;        VARIABLES
;        ALATITUDE_LL = NORTH LATITUDE OF LOWER LEFT POINT (1,1)
;                       OF GRID.  LATITUDE IS NEGATIVE FOR SOUTH
;                       LATITUDE.  MUST BE IN THE RANGE -89.9 TO
;                       +89.9.  (INPUT)
;       ALONGITUDE_LL = LONGITUDE OF LOWER LEFT POINT (1,1)
;                       OF GRID (SEE CLONG_EW).  WEST LONGITUDE 
;                       IS IMMEDIATELY CONVERTED TO EAST LONGITUDE
;                       FOR THE COMPUTATIONS.  MUST BE IN THE RANGE
;                       -360 TO +360.  (INPUT)
;       STND_PARALLEL = LATITUDE AT WHICH THE AMESH_LENGTH DISTANCE
;                       APPLIES.  LATITUDE IS NEGATIVE FOR SOUTH
;                       LATITUDE.  THE SIGN DETERMINES THE HEMISPHERE
;                       OF THE PROJECTION-- + FOR NORTHERN, - FOR
;                       SOUTHERN.  MUST BE IN THE RANGE +10 TO
;                       +89.9 FOR NORTHERN HEMISPHERIC PROJECTION AND
;                       IN THE RANGE -89.9 TO -10 FOR SOUTHERN
;                       HEMISPHERIC PROJECTION.  (INPUT)
;              ORIENT = THE ORIENTATION OF THE GRID.  THIS IS THE
;                       LONGITUDE WHICH IS ALLIGNED WITH THE Y
;                       AXIS (SEE CLONG_EW).  MUST BE IN THE RANGE
;                       -360 TO +360.  (INPUT)
;            CLONG_EW = THE CONVENTION FOR THE LONGITUDE.  THIS CAN 
;                       BE ONE OF TWO POSSIBLE VALUES:
;                         'EAST' = ALONGITUDE_LL AND ORIENT ARE EAST 
;                                  LONGITUDE.
;                         'WEST' = ALONGITUDE_LL AND ORIENT ARE WEST 
;                                  LONGITUDE.
;                       EAST (OR WEST) LONGITUDE CAN RANGE FROM -360
;                       THROUGH 360.  (CHARACTER*4)  (INPUT)
;        AMESH_LENGTH = MESH LENGTH OF GRID IN METERS AT STND_PARALLEL.
;                       (INPUT)
;    ALATITUDE(IX,IY) = LATITUDE (IX=1,NY) (IY=1,NY).  NOTE THAT
;                       THE VALUES IN THE SOUTHERN HEMISPHERE WILL
;                       BE NEGATIVE.  (INPUT/OUTPUT)
;   ALONGITUDE(IX,IY) = LONGITUDE (IX=1,NY) (IY=1,NY).  THE
;                       LONGITUDE CONVENTION (EAST OR WEST) WILL
;                       BE AS INDICATED BY CLONG_EW AND LIE IN
;                       THE RANGE 0-360.  WHEN ALATITUDE( , ) IS 
;                       EXACTLY -90 OR +90, THE LONGITUDE RETURNED
;                       WILL BE ARBITRARY.  (INPUT/OUTPUT)
;                  NX = NUMBER OF GRIDPOINTS IN THE X DIRECTION.
;                       (INPUT)
;                  NY = NUMBER OF GRIDPOINTS IN THE Y DIRECTION.
;                       (INPUT)
;               ISTAT = STATUS RETURN.  (OUTPUT, function return value)
;                       0 = GOOD RETURN.
;                       NUMBERS ASSOCIATED WITH THE VARIABLES LISTED BELOW
;                       ARE DEFINED IN HEADER FILE 'hm/HM_ERROR.inc', and
;                       comprise the other possible ISTAT values:
;                       GCT_LL_LONG_NOT_IN_RANGE = 
;                           THE VALUE IN ALONGITUDE_LL IS NOT IN
;                           THE RANGE -360 TO +360.
;                       GCT_ORIENT_LONG_NOT_IN_RANGE =
;                           THE VALUE IN ORIENT IS NOT IN
;                           THE RANGE -360 TO +360.
;                       GCT_LL_LAT_NOT_IN_RANGE = 
;                           THE VALUE IN ALATITUDE_LL IS NOT IN
;                           THE RANGE -90 TO +90.  A VALUE OF EXACTLY
;                           90 DEGREES IN THE OPPOSITE HEMISPHERE TO
;                           THE PROJECTION IS NOT ALLOWED, OR DIVISION
;                           BY ZERO WOULD OCCUR.
;                       GCT_STND_PARALLEL_NOT_IN_RANGE = 
;                           THE VALUE IN STND_PARALLEL IS NOT IN
;                           THE RANGE -90 TO +90.
;                       GCT_LONG_NOT_EAST_OR_WEST = 
;                           THE LONGITUDE CONVENTION SPECIFIED IN
;                           CLONG_EW IS NEITHER 'EAST' OR 'WEST'.
;                       GCT_MESH_LENGTH_ZERO = 
;                           THE MESH LENGTH AMESH_LENGTH IS ZERO.
;                           THIS WOULD CAUSE A DIVIDE BY ZERO.
;                       GCT_STND_PARALLEL_CLOSE_TO_EQUATOR =
;                           THE VALUE IN STND_PARALLEL IS WITHIN 
;                           10 DEGREES OF THE EQUATOR.  THE
;                           DEGENERATE FORM OF THE LAMBERT TO THE
;                           EQUATORIAL MERCATOR IS NOT ALLOWED, OR
;                           FLOATING POINT OVERFLOW WILL OCCUR (ON
;                           THE 32-BIT HP 755, THIS OCCURS AT 
;                           LESS THAN 5 DEGREES LATITUDE.  WHAT 
;                           HAPPENS IS THAT THE DISTANCE FROM THE 
;                           GRIDPOINT TO THE POLE EXCEEDS THE
;                           SIZE OF THE FLOATING POINT NUMBER OF
;                           ABOUT 10**38.)    
;                       IF THE STATUS CODE IS ANY NON ZERO VALUE,
;                       ALATITUDE( , ) AND ALONGITUDE( , ) WILL
;                       BE RETURNED AS THE MISSING VALUE RMISS.
;
;               ELON1 = EAST LONGITUDE OF LOWER LEFT POINT (1,1)
;                       OF GRID.  THE ROUTINE WAS ORIGINALLY
;                       WRITTEN IN TERMS OF EAST LONGITUDE, AND
;                       THE BASIC COMPUTATIONS HAVE NOT BEEN CHANGED.
;                       (INTERNAL)
;             EORIENT = THE ORIENTATION OF THE GRID IN DEGREES
;                       EAST LONGITUDE.  (INTERNAL)
;                 DXL = GRID LENGTH USED IN CALCULATIONS.  (INTERNAL)
;                   H = SET TO +1 FOR NORTHERN HEMISPHERIC PROJECTION
;                       AND TO -1 FOR SOUTHERN HEMSIPHERIC PROJECTION.
;                       (INTERNAL)
;               RMISS = THE MISSING VALUE INDICATOR.  (SET IN HEADER
;                       FILE)  (INTERNAL)  
;
;        ROUTINES CALLED
;           HM_HMU_LOG_ERROR (TBD)
;
;***********************************************************************

; "Include" files defining constants, error codes used here
      @HM_ERROR.inc
      @HM_CONST.inc

; Legacy FORTRAN variable declarations:
;
;      CHARACTER*4 CLONG_EW
;
;      INTEGER NX,NY
;      INTEGER IX,IY
;      INTEGER ISTAT
;
;      REAL ALATITUDE_LL, ALONGITUDE_LL
;      REAL STND_PARALLEL, ORIENT, AMESH_LENGTH
;      REAL ALATITUDE(NX,NY), ALONGITUDE(NX,NY)
;      REAL ALATN1, AN, ALA1, ARG, ANINV, ANINV2
;      REAL BETA
;      REAL COSLTN
;      REAL EORIENT, ELONVR, ELON1, ELO1
;      REAL DXL
;      REAL H
;      REAL POLEI, POLEJ
;      REAL REFLON,REBYDX,RMLL,R2
;      REAL THING,THETA
;      REAL XX
;      REAL YY
;
;***********************************************************************
;
      ISTAT=0

;        CHECK CONSISTENCY OF ARRAY SIZES AND NX AND NY (NEW, NOT PART OF THE
;        ORIGINAL FORTRAN SUBROUTINE)

      IF (NX LE 0 OR NY LE 0) THEN message, "NX or NY zero or negative!"
      salat = size(ALATITUDE)
      salon = size(ALONGITUDE)
      IF (salat[0] NE 2 OR salon[0] NE 2) THEN BEGIN
         ISTAT = GCT_ARRAY_SIZES_INCORRECT
;        CALL HM_HMU_LOG_ERROR('HM_HMU_CALC_LATLONGLAM', $
;         'INPUT ARRAYS NOT ALL 2-DIMENSIONAL', $
;         'MAJOR')
         GOTO, label195
      ENDIF
      IF (salat[1] NE NX OR salon[1] NE NX) THEN BEGIN
         ISTAT = GCT_ARRAY_SIZES_INCORRECT
;        CALL HM_HMU_LOG_ERROR('HM_HMU_CALC_LATLONGLAM', $
;         'INPUT ARRAY X-DIMENSIONS NOT ALL EQUAL TO NX', $
;         'MAJOR')
         GOTO, label195
      ENDIF
      IF (salat[2] NE NY OR salon[2] NE NY) THEN BEGIN
         ISTAT = GCT_ARRAY_SIZES_INCORRECT
;        CALL HM_HMU_LOG_ERROR('HM_HMU_CALC_LATLONGLAM', $
;         'INPUT ARRAY Y-DIMENSIONS NOT ALL EQUAL TO NY', $
;         'MAJOR')
         GOTO, label195
      ENDIF
;
;        CHECK FOR LONGITUDE OF CORNER POINT IN RANGE -360 TO +360.
;
      IF(ALONGITUDE_LL LT -360. OR ALONGITUDE_LL GT +360.) THEN BEGIN
         ISTAT=GCT_LL_LONG_NOT_IN_RANGE
;        CALL HM_HMU_LOG_ERROR('HM_HMU_CALC_LATLONGLAM', $
;         'LONGITUDE OF LL CORNER OF GRID NOT IN RANGE -360 TO +360', $
;         'MAJOR')
         GOTO, label195
      ENDIF
;
;        CHECK FOR LONGITUDE OF ORIENTATION IN RANGE -360 TO +360.
;
      IF(ORIENT LT -360. OR ORIENT GT +360.) THEN BEGIN
         ISTAT=GCT_ORIENT_LONG_NOT_IN_RANGE
;        CALL HM_HMU_LOG_ERROR('HM_HMU_CALC_LATLONGLAM', $
;          'LONGITUDE OF ORIENTATION OF GRID NOT IN RANGE -360 TO +360', $
;          'MAJOR')
         GOTO, label195
      ENDIF
;
;        CHECK FOR LATITUDE OF CORNER POINT IN RANGE -90 TO +90.
;        A LATITUDE OF EXACTLY 90 DEGREES IN THE OPPOSITE
;        HEMISPHERE THAN THE PROJECTION IS NOT ALLOWED, OR
;        DIVISION BY ZERO WOULD OCCUR.
;
      IF(STND_PARALLEL LT 0.) THEN $
         IF(ALATITUDE_LL LT -90.0 OR $
           ALATITUDE_LL GT +89.9) THEN ISTAT=GCT_LL_LAT_NOT_IN_RANGE $
      ELSE IF(ALATITUDE_LL LT -89.9  AND $
            ALATITUDE_LL GT +90.0) THEN ISTAT=GCT_LL_LAT_NOT_IN_RANGE

      IF ISTAT EQ GCT_LL_LAT_NOT_IN_RANGE THEN BEGIN
;        CALL HM_HMU_LOG_ERROR('HM_HMU_CALC_LATLONGLAM', $
;         'LATITUDE OF LL CORNER OF GRID NOT IN RANGE -90 TO +90', $
;         'MAJOR')
         GOTO, label195
      ENDIF
;
;        CONVERT WEST LONGITUDE TO EAST LONGITUDE WHEN INPUT IS IN
;        TERMS OF WEST LONGITUDE.
;        THE ROUTINE WAS ORIGINALLY WRITTEN FOR EAST LONGITUDE
;        TO BE CONSISTENT WITH GRIB USAGE.  HOWEVER, USE OF WEST
;        LONGITUDE IS USUALLY MORE CONVENIENT FOR WESTERN HEMISPHERE
;        DWELLERS.
;
      CASE CLONG_EW OF
        'WEST' : BEGIN
            ELON1=360.-ALONGITUDE_LL
            IF(ELON1 GT 360.) THEN ELON1=ELON1-360.
;           THE ABOVE STATEMENT KEEPS ELON1 IN THE RANGE 0-360.
            EORIENT=360.-ORIENT
            IF(EORIENT GT 360.) THEN EORIENT=EORIENT-360.
;           THE ABOVE STATEMENT KEEPS EORIENT IN THE RANGE 0-360.
         END
;
        'EAST' : BEGIN
            ELON1=ALONGITUDE_LL
            IF(ELON1 LT 0.) THEN ELON1=ELON1+360.
;           THE ABOVE STATEMENT KEEPS ELON1 IN THE RANGE 0-360.
            EORIENT=ORIENT
            IF(EORIENT LT 0.) THEN EORIENT=EORIENT+360.
;           THE ABOVE STATEMENT KEEPS EORIENT IN THE RANGE 0-360.
         END
;
         ELSE : BEGIN
            ISTAT=GCT_LONG_NOT_EAST_OR_WEST
;           CALL HM_HMU_LOG_ERROR('HM_HMU_CALC_LATLONGLAM', $
;             'LONGITUDE OF GRID NOT EAST OR WEST', $
;             'MAJOR')
            GOTO, label195
         END
      ENDCASE
;
;        CHECK FOR LATITUDE OF STANDARD PARALLEL IN RANGE
;        -89.9 TO +89.9.  A LATITUDE OF NEAR 0 DEGREES IS NOT
;        ALLOWED OR FLOATING POINT OVERFLOW MAY OCCUR.  ALSO, EXACTLY
;        90 DEGREES IS NOT ALLOWED, OR DIVISION BY ZERO WOULD OCCUR.
;        SET H=1 FOR THE NORTHERN HEMISPHERIC PROJECTION, -1 FOR 
;        SOUTHERN HEMISPERE.
;        REFLON IS LONGITUDE UPON WHICH THE POSITIVE X-COORDINATE
;        DRAWN THROUGH THE POLE AND TO THE RIGHT LIES
;        ROTATED AROUND FROM ORIENTATION (Y-COORDINATE) LONGITUDE
;        DIFFERENTLY IN EACH HEMISPHERE (THIS IS THE ORIGINAL
;        STACKPOLE EXPLANATION).
;
      IF( ABS(STND_PARALLEL) LT 10.)  THEN BEGIN
         ISTAT=GCT_STND_PARALLEL_CLOSE_TO_EQUATOR
;           THE STANDARD PARALLEL CANNOT BE NEAR THE EQUATOR.
;         CALL HM_HMU_LOG_ERROR('HM_HMU_CALC_LATLONGLAM', $
;          'STANDARD LATITUDE TOO NEAR THE EQUATOR FOR LAMBERT MAP', $
;          'MAJOR')
         GOTO, label195
      ENDIF

      IF( ABS(STND_PARALLEL) GT 89.9) THEN BEGIN
         ISTAT=GCT_STND_PARALLEL_NOT_IN_RANGE
;         CALL HM_HMU_LOG_ERROR('HM_HMU_CALC_LATLONGLAM', $
;          'STANDARD PARALLEL OF GRID NOT IN RANGE -90 TO +90', $
;          'MAJOR')
         GOTO, label195
      ENDIF

      IF (STND_PARALLEL LT 0) THEN BEGIN
         H=-1
         REFLON=EORIENT-90. 
      ENDIF ELSE BEGIN
         H=1
         REFLON=EORIENT-270.
      ENDELSE
;
      IF(AMESH_LENGTH EQ 0.) THEN BEGIN
         ISTAT=GCT_MESH_LENGTH_ZERO
;           GRID LENGTH CAN'T BE ZERO.
;         CALL HM_HMU_LOG_ERROR('HM_HMU_CALC_LATLONGLAM', $
;          'MESH LENGTH OF GRID IS ZERO', $
;          'MAJOR')
         GOTO, label195
      ENDIF
;
      DXL=ABS(AMESH_LENGTH)
;        IN EARLIER ROUTINES, A NEGATIVE GRIDLENGTH WAS ALLOWED.
;        THE ABSOLUTE VALUE IS TAKEN HERE JUST IN CASE.
;
;        PRELIMINARY VARIABLES AND REDEFINITIONS.
;
      REBYDX = REARTH/DXL
      ALATN1 = STND_PARALLEL * DEG2RAD
      AN = H * SIN(ALATN1)
      COSLTN = COS(ALATN1)
;
;        MAKE SURE THAT INPUT LONGITUDE DOES NOT PASS THROUGH
;        THE CUT ZONE (FORBIDDEN TERRITORY) OF THE FLAT MAP
;        AS MEASURED FROM THE VERTICAL (REFERENCE) LONGITUDE.
;
      IF((ELON1-EORIENT) GT 180.) THEN $
         ELON1 = ELON1 - 360. $
      ELSE IF((ELON1-EORIENT) LT (-180.)) THEN $
         ELON1 = ELON1 + 360.

      ELONVR = EORIENT * DEG2RAD

;        RADIUS TO LOWER LEFT HAND (LL) CORNER.

      ALA1 = ALATITUDE_LL * DEG2RAD
      RMLL = REBYDX * ((COSLTN^(1.-AN))*(1.+AN)^AN) * $
             (((COS(ALA1))/(1.+H*SIN(ALA1)))^AN)/AN

;        USE LL POINT INFO (POINT [1,1]) TO LOCATE POLE POINT.
;        USE FORTRAN CONVENTION FOR ARRAY INDICES IN COMPUTATIONS

      ELO1 = ELON1 * DEG2RAD
      ARG = AN * (ELO1-ELONVR)
      POLEI = 1. - H * RMLL * SIN(ARG)
      POLEJ = 1. + RMLL * COS(ARG)

;        COMPUTE THING FOR LATITUDE.

      ANINV = 1./AN
      ANINV2 = ANINV/2.
      THING = ( (AN/REBYDX) ^ ANINV ) / $
                ( (COSLTN^((1.-AN)*ANINV)) * (1.+ AN) )

;        RADIUS TO THE I,J POINT (IN GRID UNITS)
;        -- YY REVERSED SO POSITIVE IS DOWN

      FOR IY = 1, NY DO BEGIN
        FOR IX = 1, NX DO BEGIN
          XX = IX - POLEI
          YY = POLEJ - IY
          R2 = XX^2 + YY^2
;
;        CHECK THAT THE REQUESTED I,J IS NOT IN THE FORBIDDEN ZONE
;           YY MUST BE POSITIVE UP FOR THIS TEST
;
          THETA = HM_PI*(1.-AN)
          BETA = ABS(ATAN(XX,-YY))
          IF(BETA LE THETA) THEN BEGIN
            ; assign array values using IDL zero-based indices here and below
             ALATITUDE(IX-1,IY-1) = RMISS
             ALONGITUDE(IX-1,IY-1) = RMISS
             BREAK
          ENDIF
;
;              NOW THE MAGIC FORMULAE FOR THE LATITUDE AND LONGITUDE.
;
          IF(R2 EQ 0.) THEN BEGIN
             ALATITUDE(IX-1,IY-1) = H * 90.
             ALONGITUDE(IX-1,IY-1) = EORIENT
          ENDIF ELSE BEGIN
             ALONGITUDE(IX-1,IY-1) = EORIENT + RAD2DEG * ATAN(H*XX,YY)/AN
             ALATITUDE(IX-1,IY-1) = H * (PI_OVER_2 - 2. * $
                                ATAN(THING*(R2^ANINV2)))*RAD2DEG
;              NOTE THAT R2^ANINV2 MAY BECOME VERY LARGE AT LOW
;              VALUES OF STND_PARALLEL.
          ENDELSE
;
;           THE VALUE OF ALONGITUDE(IX,IY) CAN BE LT -0.
;           ADJUST TO KEEP THE OUTPUT LONGITUDE IN
;           THE RANGE 0 TO +360.
;
          IF(ALONGITUDE(IX-1,IY-1) LT 0.) THEN $
             ALONGITUDE(IX-1,IY-1)=ALONGITUDE(IX-1,IY-1)+360.
;         A SECOND TEST LIKE IS REQUIRED FOR THE POLAR
;         STEREOGRAPHIC MAP PROJECTON IS NOT NEEDED.
;
          IF(CLONG_EW EQ 'WEST') THEN $
             ALONGITUDE(IX-1,IY-1)=360.-ALONGITUDE(IX-1,IY-1)
;         THE OUTPUT IS IN WEST LONGITUDE WHEN THE ABOVE
;         TEST IS MET.
        ENDFOR
      ENDFOR
; 
      GOTO, label200
;
;        IN CASE OF ERRORS, RETURN GRIDS OF MISSING VALUES.
;
 label195:
      ALATITUDE(*,*)=RMISS
      ALONGITUDE(*,*)=RMISS
;     
 label200:  RETURN, ISTAT
      END     
